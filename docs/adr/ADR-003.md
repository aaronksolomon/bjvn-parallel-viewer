# ADR 003: Parallel Viewer Architecture

## Status

Proposed

## Context

The current architecture of the JVB application uses a single-threaded viewer that processes and renders data sequentially. This approach limits performance, especially when handling large datasets or complex visualizations.

## Decision

To improve performance and responsiveness, we will implement a parallel viewer architecture. This will involve:

- Splitting the rendering pipeline into multiple parallel tasks.
- Utilizing multi-threading or multi-processing to handle data processing concurrently.
- Synchronizing the rendering outputs to present a unified view.

### Implementation Details

- Use Python's `concurrent.futures` module to manage parallel tasks.
- Divide data into chunks that can be processed independently.
- Merge the processed chunks' results before final rendering.
- Ensure thread safety when accessing shared resources.

```python
from concurrent.futures import ThreadPoolExecutor

def process_chunk(chunk):
    # Process data chunk
    return processed_chunk

with ThreadPoolExecutor(max_workers=4) as executor:
    results = executor.map(process_chunk, data_chunks)

# Merge results
final_result = merge(results)
```

## Consequences

- Improved rendering speed and application responsiveness.
- Increased complexity in managing parallel tasks and synchronization.
- Potential issues with thread safety and resource contention must be addressed.

## Alternatives Considered

- Keeping the single-threaded model: simpler but less performant.
- Using GPU-based rendering: more complex and requires additional dependencies.

## References

- [Python concurrent.futures documentation](https://docs.python.org/3/library/concurrent.futures.html)
- [JVB Project Wiki: Viewer Architecture](https://github.com/jvnb-project/wiki/viewer-architecture)
