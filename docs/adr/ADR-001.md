# ADR-001: Architecture & Roadmap for JVB Parallel Viewer

Title: Architectural Decision Record — Journal of Vietnamese Buddhism (JVB) Parallel Viewer App  
Status: Accepted  
Date: 2025-09-02  
Owner: Aaron Solomon  
Repo: JVB-parallel-viewer

—

## 1. Context

We are building a parallel viewer for the Journal of Vietnamese Buddhism (JVB) archival project.
This project builds a **parallel viewer** for the **Journal of Vietnamese Buddhism** archives (1950s era, edited by Thích Nhất Hạnh).  
Each journal issue contains:

- High-resolution scanned page images.
- Vietnamese OCR text extracted from scans.
- English translations (machine-assisted, human-reviewed).

The viewer presents these three layers **side by side** to support study, translation alignment, and digital preservation.

Capacities:

1. View scanned page images.
2. View Vietnamese OCR and English translations side-by-side.
3. Navigate easily across pages and sections.
4. In the future, propose corrections to OCR and translations.
5. Maintain stable data contracts so we can evolve the backend independently.

This ADR defines the architecture, stack, models, phasing plan, and future backend options.

—

## 2. Goals

### Functional Goals

- Serve bilingual text + page scans in a polished, intuitive interface.
- Ensure stable anchors (aid) per span for future features.
- Phase in editing capabilities without blocking initial deployment.
- Support multiple backend strategies for Phase II without frontend churn.

### Non-Functional Goals

- Rapid Phase I deployment with minimal complexity.
- High-quality, accessible UI out of the box.
- Preserve flexibility for future editorial workflows.
- Enable migration to CMS-driven backends if needed.

—

## 3. Architecture Overview

### 3.1 Phase I — Viewer-Only App

Stack:

- Backend: FastAPI
- Templating: Jinja2
- UI Frameworks: TailwindCSS + DaisyUI (for polished, composable components)
- Interactive Enhancements: HTMX (lightweight dynamic interactivity)
- Page Viewer: OpenSeadragon (deep zoom, crisp scans)
- Data Source: Static JSON bundles per issue (pre-generated)
- Hosting: Fly.io / Render (containerized, single service)
- Storage: Local files for JSON + images (no DB)

Capabilities:

- Browse documents → /doc/{doc_id}.
- Pan/zoom scanned pages.
- View Vietnamese + English spans in parallel.
- JSON contract frozen to enable seamless backend replacement.

### 3.2 Phase II — Editable Backend

Enhancements:

- Add paragraph-level editing + revision history.
- Preserve stable aid anchors for tracking changes.
- Implement moderation workflows.
- Introduce forms and editing capabilities starting in this phase.

Backend Options:

- Option A: SQLite + Custom Revisions (default path)
  - Keep FastAPI/Jinja UI.
  - Add spans + revisions tables.
  - Store immutable edit history.
  - Backup via Litestream → S3/B2.

- Option B: Integrate Wagtail as Editorial Backend
  - Use Wagtail for content storage, revisions, and workflows.
  - Keep the existing FastAPI viewer OR migrate templates into Wagtail.
  - Wagtail exposes /api/doc/{doc_id}.json to serve the same bundle schema.

- Option C: Hybrid CMS + FastAPI
  - Run Wagtail separately at admin.JVB.org.
  - Editors manage spans; FastAPI viewer fetches bundles via REST.

—

## 4. Data Model & Contracts

### 4.1 JSON Bundle Schema (frozen)

This schema is the public API contract between backend(s) and frontend:

json
{
  "doc_id": "ang_v_1956_issue5",
  "title": "Phật Giáo Việt Nam — ANG.V",
  "pages": [
    { "page": 1, "image": "/images/angv_p001.jpg" },
    { "page": 2, "image": "/images/angv_p002.jpg" }
  ],
  "sections": [
    {
      "sid": "s1",
      "title_vi": "NHỮNG NGÀY HOAN-HỶ",
      "title_en": "Joyful Days",
      "spans": [
        {
          "aid": "angv:s1:p1",
          "page": 4,
          "vi": "...",
          "en": "..."
        }
      ]
    }
  ]
}

#### Key Notes

- aid = stable paragraph anchor ({doc_id}:{section_id}:{paragraph_id}).
- pages[] = ordered scans, allows OpenSeadragon linking.
- spans[] = ordered bilingual paragraph units.
- Metadata (like translation notes) may be added later, but core keys must remain stable.

### 4.2 SQLite Schema (Phase II, Option A)

sql
-- Table of documents
CREATE TABLE documents (
    id TEXT PRIMARY KEY,
    title TEXT
);

-- Latest state of each span
CREATE TABLE spans (
    aid TEXT PRIMARY KEY,
    doc_id TEXT,
    page INTEGER,
    vi TEXT,
    en TEXT,
    version INTEGER
);

-- Immutable revision history
CREATE TABLE revisions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    aid TEXT,
    lang TEXT,
    prev_version INTEGER,
    new_version INTEGER,
    old_text TEXT,
    new_text TEXT,
    created_at TEXT,
    user_hint TEXT
);

This supports:

- Conflict detection (version compare before commit).
- Full audit trail.
- Easy syncing to Wagtail or other CMS if needed.

### 4.3 Wagtail Model Mapping (Phase II, Option B)

python
class Document(Page):
    doc_id = models.SlugField(unique=True)
    title = models.CharField(max_length=255)

class Span(models.Model):
    document = models.ForeignKey(Document, related_name="spans", on_delete=models.CASCADE)
    aid = models.CharField(max_length=100, unique=True)
    page = models.IntegerField()
    vi = models.TextField(blank=True)
    en = models.TextField(blank=True)

class SpanRevision(models.Model):
    span = models.ForeignKey(Span, related_name="revisions", on_delete=models.CASCADE)
    lang = models.CharField(max_length=2, choices=[("vi","Vietnamese"),("en","English")])
    prev_version = models.IntegerField()
    new_version = models.IntegerField()
    old_text = models.TextField()
    new_text = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    user_hint = models.CharField(max_length=200, blank=True)

Wagtail automatically provides:

- Built-in revisions per page/field.
- Editorial dashboards and workflows.
- REST API endpoints for exporting bundles.

—

## 5. Phasing Plan

### Phase I — MVP (Viewer-Only)

| Feature        | Status | Stack           |
|---------------|--------|-----------------|
| View scans    | ✅     | OpenSeadragon   |
| View VN + EN  | ✅     | FastAPI + Jinja |
| Navigate pages| ✅     | JSON bundle contract |

### Phase II — Enhanced Editing

| Capability        | Option A: SQLite | Option B: Wagtail |
|-------------------|------------------|-------------------|
| Inline editing    | ✅               | ✅                |
| Revision history  | ✅               | ✅                |
| Moderation workflow| ⚠️ manual       | ✅ built-in       |
| REST API for bundles| ✅ custom       | ✅ built-in       |
| Admin dashboard   | ❌               | ✅                |
| External integrations| Manual         | Rich Wagtail ecosystem |
| Forms and editing | Introduced here  | Introduced here   |

—

## 6. Risks & Mitigations

| Risk                   | Impact | Mitigation                                 |
|------------------------|--------|--------------------------------------------|
| Lock-in to custom edit code | Medium | Keep JSON schema stable; Wagtail can reproduce API |
| OCR alignment errors    | High   | Use AI-assisted alignment later; maintain aid anchors |
| Phase II complexity     | High   | Start with smallest viable SQLite + HTMX edit flow |
| Hosting costs          | Low    | Start on Fly.io free-tier; consider Netlify for static assets |

—

## 7. Decision Summary

- Phase I: Viewer-first, minimal FastAPI + JSON bundles + Tailwind + DaisyUI.
- Editing Deferred: No forms or editing in Phase I.
- Freeze Bundle Contract: Frontend consumes a stable JSON API that any backend can emit.
- Phase II Options:
    1. SQLite module (lightweight, easy)
    2. Wagtail CMS (full editorial power)
    3. Hybrid FastAPI + Wagtail REST integration.

—

## 8. Next Steps

1. Complete repository skeleton (done).  
2. Generate JSON bundles from XML source using AI-assisted conversion.  
3. Build a verification pass to detect missing elements, malformed anchors, and inconsistent page mappings.  
4. Create sample datasets and confirm alignment with images.  
5. Stage for Fly.io deploy.  
6. Plan Phase II editorial module and forms.

—

## 9. Appendix

- Repo name: JVB-parallel-viewer
- Bundle source: data/*.json
- Images directory: images/*.jpg
- API contract: /api/doc/{doc_id}.json
- Preferred backend roadmap: FastAPI → SQLite → optional Wagtail

—

Outcome:
This ADR establishes a clear contract-first design and phased roadmap for the JVB Parallel Viewer. By separating the frontend viewer from backend persistence concerns, we preserve optionality and allow a smooth upgrade path to SQLite or Wagtail while delivering a polished MVP quickly

## Next AI steps

Generate a complete repo skeleton next, matching this ADR, including directories, starter FastAPI app, templates, and example JSON
